题目描述：
验证给定的字符串是否可以解释为十进制数字。
###############################################################
例如：
"0" => true
" 0.1 " => true
"abc" => false
"1 a" => false
"2e10" => true
" -90e3   " => true
" 1e" => false
"e3" => false
" 6e-1" => true
" 99e2.5 " => false
"53.5e93" => true
" --6 " => false
"-+3" => false
"95a54e53" => false

说明: 我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。这里给出一份可能存在于有效十进制数字中的字符列表：

数字 0-9
指数 - "e"
正/负号 - "+"/"-"
小数点 - "."
###############################################################
解题思路：'.'会匹配任意字符；'*'会匹配前一个字符的0个或多个。重点放在'*'的情况判别上。如果不存在'*'时，那么就正常比较，一个字符对应一个。
         如果存在'*'，情况就比较复杂，分三种情况：'*'匹配0个字符、'*'匹配字符'.'（1个或多个字符）、'*'匹配不为'.'的字符（1个或多个字符）。
         其中第二种和第三种情况需要使用while循环,内部使用递归判断是否满足True条件。
         True条件：len(p) == 0 and len(s) == 0
python代码:
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        # '.'会匹配任意字符；'*'会匹配前一个字符的0个或多个
        if len(p) == 0:
            return len(s) == 0  # 返回True的条件
        if len(p) == 1 or p[1] != '*':
            if len(s) == 0 or (s[0] != p[0] and p[0] != '.'):
                return False
            return self.isMatch(s[1:],p[1:])
        else:
            i = -1
            lenght = len(s)
            while i < lenght and (i < 0 or p[0] == '.' or p[0] == s[i]):
                if self.isMatch(s[i+1:], p[2:]):
                    return True
                i += 1
            return False
